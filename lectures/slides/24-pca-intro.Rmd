---
title: "24 Principal components, introduction"
author: 
  - "STAT 406"
  - "Daniel J. McDonald"
date: 'Last modified - `r Sys.Date()`'
---

class: middle, center
background-image: url(rmd_gfx/23-nnets-other/embeddings-1.svg)
background-size: cover

$$\newcommand{\Expect}[1]{\mathbb{E}\left[ #1 \right]}
\newcommand{\Var}[1]{\mathrm{Var}\left[ #1 \right]}
\newcommand{\Cov}[2]{\mathrm{Cov}\left[#1,\ #2\right]}
\newcommand{\given}{\ \vert\ }
\newcommand{\argmin}{\arg\min}
\newcommand{\argmax}{\arg\max}
\newcommand{\R}{\mathbb{R}}
\newcommand{\P}{P}
\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\renewcommand{\hat}{\widehat}
\newcommand{\tr}[1]{\mbox{tr}(#1)}
\newcommand{\X}{\mathbf{X}}
\newcommand{\y}{\mathbf{y}}
\newcommand{\x}{\mathbf{x}}
\newcommand{\U}{\mathbf{U}}
\newcommand{\D}{\mathbf{D}}
\newcommand{\V}{\mathbf{V}}$$


```{r setup, include=FALSE, warning=FALSE, message=FALSE}
source("rmd_config.R")
```


.primary[.larger[Module]] .huge-orange-number[5]

.primary[.larger[pca, clustering]]

---


```{r css-extras, file="css-extras.R", echo=FALSE}
```


## Unsupervised learning

In Machine Learning, rather than calling $\y$ the .hand[response], people call it the .hand[supervisor]

So .hand[unsupervised] learning means .hand[learning without] $\y$

The only data you get are the .hand[features] $\{x_1,\ldots,x_n\}$.

This type of analysis is more often .hand[exploratory]

We're not necessarily using this for prediction (but we could)

So now, we get $\X$

The two main activities are __representation learning__ and __clustering__

---


## Representation learning

Representation learning is the idea that performance of ML methods is
highly dependent on the choice of representation


For this reason, much of ML is geared towards transforming the data into
the relevant features and then using these as inputs


This idea is as old as statistics itself, really,

However, the idea is constantly revisited in a variety of fields and
contexts


Commonly, these learned representations capture low-level information
like overall shapes



It is possible to quantify this intuition for PCA at least

--

.hand[Goal:] Transform $\mathbf{X}\in \R^{n\times p}$ into $\mathbf{Z} \in \R^{n \times ?}$

?-dimension can be bigger (feature creation) or smaller (dimension reduction) than $p$


---

## You've done this already!

* You added transformations as predictors in regression

* You "expanded" $\mathbf{X}$ using a basis $\Phi$ (polynomials, splines, etc.)

* You used Neural Nets to do a "feature map"

--

This is the same, just no $Y$ around

---

## PCA

Principal components analysis (PCA) is an (unsupervised) dimension
reduction technique


It solves various equivalent optimization problems

(Maximize variance, minimize $\ell_2$ distortions, find closest subspace of a given rank, $\ldots$)

At its core, we are finding linear combinations of the original
(centered) covariates $$z_{ij} = \alpha_j^{\top} x_i$$


This is expressed via the SVD. 

$$\X  = \U\D\V^{\top}$$

--

.secondary[Warning:] We assume throughout that $\X - \mathbf{11^\top}\overline{x} = 0$ (we center the columns)

--

Then our new features are

$$\mathbf{Z} = \X \V = \U\D$$

---

## Short SVD aside (reminder from Ridge Regression)

* Any $n\times p$ matrix can be decomposed into $\mathbf{UDV}^\top$.

* These have properties:

1. $\mathbf{U}^\top \mathbf{U} = \mathbf{I}_n$
2. $\mathbf{V}^\top \mathbf{V} = \mathbf{I}_p$
3. $\mathbf{D}$ is diagonal (0 off the diagonal)

--

Almost all the methods for we'll talk about for representation learning use the SVD of some matrix.


---
class: inverse

## Why?

1. Given $\X$, find a projection $\mathbf{P}$ onto $\R^M$ with $M \leq p$ 
that minimizes the reconstruction error
$$
\begin{aligned}
\min_{\mathbf{P}} &\,\, \lVert \mathbf{X} - \mathbf{X}\mathbf{P} \rVert^2_F \,\,\, \textrm{(sum all the elements)}\\
\textrm{subject to} &\,\, \textrm{rank}(\mathbf{P}) = M,\, \mathbf{P} = \mathbf{P}^T,\, \mathbf{P} = \mathbf{P}^2
\end{aligned}
$$
The conditions ensure that $\mathbf{P}$ is a projection matrix onto $M$ dimensions.

2. Maximize the variance explained by an orthogonal transformation $\mathbf{A} \in \R^{p\times M}$
$$
\begin{aligned}
\max_{\mathbf{A}} &\,\, \textrm{trace}\left(\frac{1}{n}\mathbf{A}^\top \X^\top \X \mathbf{A}\right)\\
\textrm{subject to} &\,\, \mathbf{A}^\top\mathbf{A} = \mathbf{I}_M
\end{aligned}
$$

* In case one, the minimizer is $\mathbf{P} = \mathbf{V}_M\mathbf{V}_M^\top$
* In case two, the maximizer is $\mathbf{A} = \mathbf{V}_M$.


---

## Lower dimensional embeddings

Suppose we have predictors $\x_1$ and $\x_2$

-   We more faithfully preserve the structure of this data by keeping
    $\x_1$ and setting $\x_2$ to zero than the opposite

```{r, echo=FALSE, fig.align='center', fig.width=10, fig.height=5}
df = data.frame(x1=rep(rnorm(20,sd=1),3),x2=rep(rnorm(20,sd=.2),3),
                lab = rep(c('data','x2 only','x1 only'),each=20))
df[21:40,1] = 0
df[41:60,2] = 0
ggplot(df,aes(x1,x2,color=lab)) + geom_point() + 
  coord_cartesian(c(-2,2), c(-2,2)) +
  scale_color_manual(values=c(blue,orange,green)) +
  facet_wrap(~lab) +
  theme(legend.title = element_blank(), legend.position = 'none')
```

---

## Lower dimensional embeddings

An important feature of the previous example is that $\x_1$ and $\x_2$ aren't
correlated

What if they are?

```{r, echo=FALSE, fig.align='center', fig.width=10, fig.height=4}
#library(UBCstat406labs)
theta = -pi/4
R = matrix(c(cos(theta),sin(theta),-sin(theta),cos(theta)),2)
X = as.matrix(df[1:20,1:2]) %*% R
df2 = data.frame(x1=rep(X[,1],3),x2=rep(X[,2],3),
                lab = rep(c('data','x2 only','x1 only'),each=20))
df2[21:40,1] = 0
df2[41:60,2] = 0
ggplot(df2,aes(x1,x2,color=lab)) + geom_point() + 
  scale_color_manual(values=c(blue,orange,green)) +
  coord_cartesian(c(-2,2), c(-2,2)) +
  facet_wrap(~lab) +
  theme(legend.title = element_blank(), legend.position = 'none')
```

We lose a lot of structure by setting either $\x_1$ or $\x_2$ to zero


---

## Lower dimensional embeddings


The only difference is the first is a rotation of the second

```{r, echo=FALSE, fig.align='center',fig.width=10,fig.height=4}
df3 = bind_rows(df,df2)
df3$version = rep(c('original','rotated'),each=60)
df3 %>% 
  ggplot(aes(x1,x2,color=lab)) + geom_point() + 
  scale_color_manual(values=c(blue,orange,green)) +
  coord_cartesian(c(-2,2),c(-2,2)) + 
  facet_grid(~version) + 
  theme(legend.title = element_blank(), legend.position = 'bottom')
```

---

## PCA

.pull-left[
If we knew how to rotate our data, then we could more easily retain the structure.

__PCA__ gives us exactly this rotation

]

.pull-right[

.emphasis[
1. Center (+scale?) the data matrix $\X$
2. Compute the SVD of $\X = \U\D \V^\top$ or $\X\X^\top = \U\D^2\U^\top$ or $\X^\top \X = \V\D^2 \V^\top$
3. Return $\U_M\D_M$, where $\D_M$ is the largest $M$
    eigenvalues of $\X$
]]

```{r pca-leaf}
leaf <- readRDS("data/leaf.rds")
X <- leaf %>% dplyr::select(Eccentricity:Entropy)
pca <- prcomp(X, scale = TRUE) ## DON'T USE princomp()
```



```{r pca-leaf-plot, fig.align='center',fig.height=3,fig.width=10,echo=FALSE}
library(cowplot)
proj_pca <- as.matrix(X) %*% pca$rotation[,1:2] %>% scale() %>% as_tibble()
proj_pca$species = as.factor(leaf$Species)
g1 = ggplot(proj_pca, aes(PC1,PC2,color=species)) + 
  geom_point() + theme(legend.position = 'none') +
  scale_color_viridis_d()
g2 = ggplot(tibble(var_explained=pca$sdev^2/sum(pca$sdev^2), M=1:ncol(X)),
            aes(M, var_explained))+ geom_point(color=orange) + 
  geom_segment(aes(xend=M,yend=0), color=blue)
plot_grid(g1,g2)
```

---
class: middle, inverse, center

# Next time...

When does PCA work?


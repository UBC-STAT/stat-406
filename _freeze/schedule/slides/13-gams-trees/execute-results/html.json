{
  "hash": "fce72a85ba37a5798f88dd03851efd87",
  "result": {
    "engine": "knitr",
    "markdown": "---\nlecture: \"13 GAMs and Trees\"\nformat: revealjs\nmetadata-files: \n  - _metadata.yml\n---\n\n\n## {{< meta lecture >}} {.large background-image=\"gfx/smooths.svg\" background-opacity=\"0.3\"}\n\n[Stat 406]{.secondary}\n\n[{{< meta author >}}]{.secondary}\n\nLast modified -- 08 October 2024\n\n\n\n\n\n$$\n\\DeclareMathOperator*{\\argmin}{argmin}\n\\DeclareMathOperator*{\\argmax}{argmax}\n\\DeclareMathOperator*{\\minimize}{minimize}\n\\DeclareMathOperator*{\\maximize}{maximize}\n\\DeclareMathOperator*{\\find}{find}\n\\DeclareMathOperator{\\st}{subject\\,\\,to}\n\\newcommand{\\E}{E}\n\\newcommand{\\Expect}[1]{\\E\\left[ #1 \\right]}\n\\newcommand{\\Var}[1]{\\mathrm{Var}\\left[ #1 \\right]}\n\\newcommand{\\Cov}[2]{\\mathrm{Cov}\\left[#1,\\ #2\\right]}\n\\newcommand{\\given}{\\ \\vert\\ }\n\\newcommand{\\X}{\\mathbf{X}}\n\\newcommand{\\x}{\\mathbf{x}}\n\\newcommand{\\y}{\\mathbf{y}}\n\\newcommand{\\P}{\\mathcal{P}}\n\\newcommand{\\R}{\\mathbb{R}}\n\\newcommand{\\norm}[1]{\\left\\lVert #1 \\right\\rVert}\n\\newcommand{\\snorm}[1]{\\lVert #1 \\rVert}\n\\newcommand{\\tr}[1]{\\mbox{tr}(#1)}\n\\newcommand{\\brt}{\\widehat{\\beta}^R_{s}}\n\\newcommand{\\brl}{\\widehat{\\beta}^R_{\\lambda}}\n\\newcommand{\\bls}{\\widehat{\\beta}_{ols}}\n\\newcommand{\\blt}{\\widehat{\\beta}^L_{s}}\n\\newcommand{\\bll}{\\widehat{\\beta}^L_{\\lambda}}\n\\newcommand{\\U}{\\mathbf{U}}\n\\newcommand{\\D}{\\mathbf{D}}\n\\newcommand{\\V}{\\mathbf{V}}\n$$\n\n\n\n\n\n## GAMs\n\nLast time we discussed smoothing in multiple dimensions.\n\n\nHere we introduce the concept of GAMs ([G]{.secondary}eneralized [A]{.secondary}dditive [M]{.secondary}odels)\n\nThe basic idea is to imagine that the response is the sum of some functions of the predictors:\n\n$$\\Expect{Y \\given X=x} = \\beta_0 + f_1(x_{1})+\\cdots+f_p(x_{p}).$$\n\n\nNote that OLS [is]{.secondary} a GAM (take $f_j(x_{j})=\\beta_j x_{j}$):\n\n$$\\Expect{Y \\given X=x} = \\beta_0 + \\beta_1 x_{1}+\\cdots+\\beta_p x_{p}.$$\n\n## Gams\n\nThese work by estimating each $f_i$ using basis expansions in predictor $i$\n\nThe algorithm for fitting these things is called \"backfitting\" (very similar to the CD intuition for lasso):\n\n\n1. Center $\\y$ and $\\X$.\n2. Hold $f_k$ for all $k\\neq j$ fixed, and regress $\\X_j$ on $(\\y - \\widehat{\\y}_{-j})$ using your favorite smoother.\n3. Repeat for $1\\leq j\\leq p$.\n4. Repeat steps 2 and 3 until the estimated functions \"stop moving\" (iterate)\n5. Return the results.\n\n\n\n## Very small example\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(mgcv)\nset.seed(12345)\nn <- 500\nsimple <- tibble(\n  x1 = runif(n, 0, 2*pi),\n  x2 = runif(n),\n  y = 5 + 2 * sin(x1) + 8 * sqrt(x2) + rnorm(n, sd = .25)\n)\n\npivot_longer(simple, -y, names_to = \"predictor\", values_to = \"x\") |>\n  ggplot(aes(x, y)) +\n  geom_point(col = blue) +\n  facet_wrap(~predictor, scales = \"free_x\")\n```\n\n::: {.cell-output-display}\n![](13-gams-trees_files/figure-revealjs/unnamed-chunk-1-1.svg){fig-align='center'}\n:::\n:::\n\n\n\n## Very small example\n\nSmooth each coordinate independently\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nex_smooth <- gam(y ~ s(x1) + s(x2), data = simple)\n# s(z) means \"smooth\" z, uses spline basis for each with ridge penalty, GCV\nplot(ex_smooth, pages = 1, scale = 0, shade = TRUE, \n     resid = TRUE, se = 2, las = 1)\n```\n\n::: {.cell-output-display}\n![](13-gams-trees_files/figure-revealjs/gam-mod-1.svg){fig-align='center'}\n:::\n\n```{.r .cell-code}\nhead(coef(ex_smooth))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept)     s(x1).1     s(x1).2     s(x1).3     s(x1).4     s(x1).5 \n 10.2070490  -4.5764100   0.7117161   0.4548928   0.5535001  -0.2092996 \n```\n\n\n:::\n\n```{.r .cell-code}\nex_smooth$gcv.ubre\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    GCV.Cp \n0.06619721 \n```\n\n\n:::\n:::\n\n\n\n\n## Wherefore GAMs?\n\n\nIf \n\n$\\Expect{Y \\given X=x} = \\beta_0 + f_1(x_{1})+\\cdots+f_p(x_{p}),$\n\nthen\n\n$$\nR_n^{(\\mathrm{GAM})} =\n  \\underbrace{\\frac{C_1^{(\\mathrm{GAM})}}{n^{4/5}}}_{\\mathrm{bias}^2} +\n  \\underbrace{\\frac{C_2^{(\\mathrm{GAM})}}{n^{4/5}}}_{\\mathrm{var}} +\n  \\sigma^2.\n$$\nCompare with OLS and non-additive local smoothers:\n\n$$\nR_n^{(\\mathrm{OLS})} =\n  \\underbrace{C_1^{(\\mathrm{OLS})}}_{\\mathrm{bias}^2} +\n  \\underbrace{\\tfrac{C_2^{(\\mathrm{OLS})}}{n/p}}_{\\mathrm{var}} +\n  \\sigma^2,\n\\qquad\nR_n^{(\\mathrm{local})} =\n  \\underbrace{\\tfrac{C_1^{(\\mathrm{local})}}{n^{4/(4+p)}}}_{\\mathrm{bias}^2} +\n  \\underbrace{\\tfrac{C_2^{(\\mathrm{local})}}{n^{4/(4+p)}}}_{\\mathrm{var}} +\n  \\sigma^2.\n$$\n\n---\n\n* We no longer have an exponential dependence on $p$!\n\n* But our predictor is restrictive to functions that decompose additively.\n  (This is a big limitation.)\n\n* You could also use the same methods to include \"some\" interactions like\n\n$$\\begin{aligned}&\\Expect{Y \\given X=x}\\\\ &= \\beta_0 + f_{12}(x_{1},\\ x_{2})+f_3(x_3)+\\cdots+f_p(x_{p}),\\end{aligned}$$\n\n## Very small example\n\nSmooth two coordinates together\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nex_smooth2 <- gam(y ~ s(x1, x2), data = simple)\nplot(ex_smooth2,\n  scheme = 2, scale = 0, shade = TRUE,\n  resid = TRUE, se = 2, las = 1\n)\n```\n\n::: {.cell-output-display}\n![](13-gams-trees_files/figure-revealjs/unnamed-chunk-2-1.svg){fig-align='center'}\n:::\n:::\n\n\n\n\n\n## Regression trees\n\n* Trees involve stratifying or segmenting the predictor space into a number of simple regions.\n* Trees are simple and useful for interpretation.  \n* Basic trees are not great at prediction. \n* Modern methods that use trees are much better (Module 4)\n\n\n## Example with mobility data\n\n::: flex\n::: w-50\n\n\"Small\" tree\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\ndata(\"mobility\", package = \"Stat406\")\nlibrary(tree)\nlibrary(maptree)\nmob <- mobility[complete.cases(mobility), ] %>% dplyr::select(-ID, -Name)\nset.seed(12345)\npar(mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0))\nbigtree <- tree(Mobility ~ ., data = mob)\nsmalltree <- prune.tree(bigtree, k = .09)\ndraw.tree(smalltree, digits = 2)\n```\n\n::: {.cell-output-display}\n![](13-gams-trees_files/figure-revealjs/unnamed-chunk-3-1.svg){fig-align='center'}\n:::\n:::\n\n\n:::\n\n::: w-50\n\"Big\" tree\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](13-gams-trees_files/figure-revealjs/big-tree-1.svg){fig-align='center'}\n:::\n:::\n\n\n:::\n:::\n\n[Terminology]{.secondary}\n\n* We call each split or end point a *node*.\n* Each terminal node is referred to as a *leaf*.\n\n## Example with mobility data\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nmob$preds <- predict(smalltree)\npar(mfrow = c(1, 2), mar = c(5, 3, 0, 0))\ndraw.tree(smalltree, digits = 2)\ncols <- viridisLite::viridis(20, direction = -1)[cut(log(mob$Mobility), 20)]\nplot(mob$Black, mob$Commute,\n  pch = 19, cex = .4, bty = \"n\", las = 1, col = cols,\n  ylab = \"Commute time\", xlab = \"% Black\"\n)\npartition.tree(smalltree, add = TRUE, ordvars = c(\"Black\", \"Commute\"))\n```\n\n::: {.cell-output-display}\n![](13-gams-trees_files/figure-revealjs/partition-view-1.svg){fig-align='center'}\n:::\n:::\n\n\n\n\n[(The three regions correspond to the leaves of the tree.)]{.small}\n\\\n\n* Trees are *piecewise constant functions*.\\\n  [We predict all observations in a region with the same value.]{.small}\n* Prediction regions are axis-parallel rectangles $R_1,\\ldots,R_K$ based on $\\X$\n\n\n\n<!-- ## -->\n\n\n<!-- ![](https://www.aafp.org/dam/AAFP/images/journals/blogs/inpractice/covid_dx_algorithm4.png) -->\n\n\n<!-- ## Dendrogram view -->\n\n<!-- ```{r} -->\n<!-- #| code-fold: true -->\n<!-- #| fig-width: 8 -->\n<!-- data(\"mobility\", package = \"Stat406\") -->\n<!-- library(tree) -->\n<!-- library(maptree) -->\n<!-- mob <- mobility[complete.cases(mobility), ] %>% dplyr::select(-ID, -Name) -->\n<!-- set.seed(12345) -->\n<!-- par(mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0)) -->\n<!-- smalltree <- prune.tree(bigtree, k = .09) -->\n<!-- draw.tree(smalltree, digits = 2) -->\n<!-- ``` -->\n\n<!-- This is called the [dendrogram]{.secondary} -->\n\n\n<!-- ## Partition view -->\n\n<!-- ```{r partition-view} -->\n<!-- #| code-fold: true -->\n<!-- #| fig-width: 10 -->\n<!-- mob$preds <- predict(smalltree) -->\n<!-- par(mfrow = c(1, 2), mar = c(5, 3, 0, 0)) -->\n<!-- draw.tree(smalltree, digits = 2) -->\n<!-- cols <- viridisLite::viridis(20, direction = -1)[cut(log(mob$Mobility), 20)] -->\n<!-- plot(mob$Black, mob$Commute, -->\n<!--   pch = 19, cex = .4, bty = \"n\", las = 1, col = cols, -->\n<!--   ylab = \"Commute time\", xlab = \"% Black\" -->\n<!-- ) -->\n<!-- partition.tree(smalltree, add = TRUE, ordvars = c(\"Black\", \"Commute\")) -->\n<!-- ``` -->\n\n\n\n## Constructing Trees\n\n::: flex\n::: w-60\n\nIterative algorithm:\n\n* While ($\\mathtt{depth} \\ne \\mathtt{max.depth}$):\n    * For each existing region $R_k$\n        * For a given *splitting variable* $j$ and *split value* $s$,\n          define\n          $$\n          \\begin{align}\n          R_k^> &= \\{x \\in R_k : x^{(j)} > s\\} \\\\\n          R_k^< &= \\{x \\in R_k : x^{(j)} > s\\}\n          \\end{align}\n          $$\n        * Choose $j$ and $s$ \n          to minimize\n          $$|R_k^>| \\cdot \\widehat{Var}(R_k^>) + |R_k^<| \\cdot  \\widehat{Var}(R_k^<)$$\n\n:::\n\n::: w-35\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](13-gams-trees_files/figure-revealjs/unnamed-chunk-4-1.svg){fig-align='center'}\n:::\n:::\n\n\n::: fragment\nThis algorithm is *greedy*, so it doesn't find the optimal tree\\\n[(But it works well!)]{.small}\n\n:::\n:::\n:::\n\n\n## Advantages and disadvantages of trees\n\nðŸŽ‰ Trees are very easy to explain (much easier than even linear regression).  \n\nðŸŽ‰ Some people believe that decision trees mirror human decision.  \n\nðŸŽ‰ Trees can easily be displayed graphically no matter the dimension of the data.\n\nðŸŽ‰ Trees can easily handle categorical predictors without the need to create one-hot encodings.\n\nðŸŽ‰ *Trees are GREAT for missing data!!!*\n\nðŸ’© Trees aren't very good at prediction.\n\nðŸ’© Big trees badly overfit, so we \"prune\" them using CV \n\n. . .\n\n[We'll talk more about trees next module for Classification.]{.hand}\n\n# Next time ... {background-image=\"gfx/proforhobo.png\" background-opacity=.3}\n\n\nModule 3\n\nClassification\n\n",
    "supporting": [
      "13-gams-trees_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}